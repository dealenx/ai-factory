import chalk from 'chalk';
import path from 'path';
import { runWizard } from '../wizard/prompts.js';
import { installSkills, installRemoteSkill } from '../../core/installer.js';
import { saveConfig, configExists, loadConfig, getCurrentVersion, type AgentInstallation, type RemoteSkill } from '../../core/config.js';
import { configureMcp, getMcpInstructions } from '../../core/mcp.js';
import { getAgentConfig } from '../../core/agents.js';
import { getTransformer } from '../../core/transformer.js';
import { WORKFLOW_SKILLS } from '../../core/transformer.js';
import { fileExists, removeDirectory, removeFile } from '../../utils/fs.js';

async function removeAgentSetup(projectDir: string, agent: AgentInstallation): Promise<void> {
  const agentConfig = getAgentConfig(agent.id);

  await removeDirectory(path.join(projectDir, agent.skillsDir));

  if (agent.id === 'antigravity') {
    const workflowsDir = path.join(projectDir, agentConfig.configDir, 'workflows');
    for (const workflow of WORKFLOW_SKILLS) {
      const workflowFile = path.join(workflowsDir, `${workflow}.md`);
      if (await fileExists(workflowFile)) {
        await removeFile(workflowFile);
      }
    }

    for (const ruleFile of ['aif-guardrails.md', 'aif-conventions.md']) {
      const rulePath = path.join(projectDir, agentConfig.configDir, 'rules', ruleFile);
      if (await fileExists(rulePath)) {
        await removeFile(rulePath);
      }
    }
  }

  // Keep agent settings file intact: it may contain user-managed configuration
  // unrelated to AI Factory.
}

export async function initCommand(): Promise<void> {
  const projectDir = process.cwd();

  console.log(chalk.bold.blue('\nðŸ­ AI Factory - Project Setup\n'));

  const hasExistingConfig = await configExists(projectDir);
  const existingConfig = hasExistingConfig ? await loadConfig(projectDir) : null;

  if (hasExistingConfig) {
    console.log(chalk.yellow('Warning: .ai-factory.json already exists.'));
    console.log('Running init will reconfigure selected agents (add/remove) and reinstall base skills.\n');
  }

  try {
    const existingAgentIds = existingConfig?.agents.map(agent => agent.id) ?? [];
    const answers = await runWizard(projectDir, existingAgentIds);

    const selectedAgentIds = new Set(answers.agents.map(agent => agent.id));
    const removedAgents = (existingConfig?.agents ?? []).filter(agent => !selectedAgentIds.has(agent.id));

    if (removedAgents.length > 0) {
      console.log(chalk.dim('\nRemoving deselected agent setups...\n'));
      for (const removedAgent of removedAgents) {
        await removeAgentSetup(projectDir, removedAgent);
        console.log(chalk.yellow(`  Removed: ${removedAgent.id}`));
      }
    }

    console.log(chalk.dim('\nInstalling skills...\n'));

    const installedAgents: AgentInstallation[] = [];
    const mcpSummary: Record<string, string[]> = {};

    for (const agentSelection of answers.agents) {
      const agentConfig = getAgentConfig(agentSelection.id);

      const installedSkills = await installSkills({
        projectDir,
        skillsDir: agentConfig.skillsDir,
        skills: answers.selectedSkills,
        stack: null, // Stack-specific skills generated by /aif in Claude
        agentId: agentSelection.id,
      });

      const configuredMcp = await configureMcp(projectDir, {
        github: agentSelection.mcpGithub,
        filesystem: agentSelection.mcpFilesystem,
        postgres: agentSelection.mcpPostgres,
        chromeDevtools: agentSelection.mcpChromeDevtools,
      }, agentSelection.id);

      if (configuredMcp.length > 0) {
        mcpSummary[agentSelection.id] = configuredMcp;
      }

      // Preserve remote skills from previous config if the agent existed before
      const previousAgent = existingConfig?.agents.find(a => a.id === agentSelection.id);
      const remoteSkills = previousAgent?.remoteSkills ?? [];

      installedAgents.push({
        id: agentSelection.id,
        skillsDir: agentConfig.skillsDir,
        installedSkills,
        remoteSkills,
        mcp: {
          github: agentSelection.mcpGithub,
          filesystem: agentSelection.mcpFilesystem,
          postgres: agentSelection.mcpPostgres,
          chromeDevtools: agentSelection.mcpChromeDevtools,
        },
      });
    }

    // Sync remote skills: copy from existing agent to newly added agents (no download)
    const previousRemoteSkills = collectUniqueRemoteSkills(existingConfig?.agents ?? []);
    if (previousRemoteSkills.length > 0) {
      const previousAgentIds = new Set(existingConfig?.agents.map(a => a.id) ?? []);
      const newAgents = installedAgents.filter(a => !previousAgentIds.has(a.id));

      if (newAgents.length > 0) {
        // Find a source agent that has the skill files on disk
        const sourceAgent = existingConfig!.agents.find(a => a.remoteSkills.length > 0)!;
        const sourceSkillsDir = path.join(projectDir, sourceAgent.skillsDir);

        console.log(chalk.dim('Syncing remote skills to new agents...\n'));

        for (const rs of previousRemoteSkills) {
          const sourceSkillDir = path.join(sourceSkillsDir, rs.name);

          if (!(await fileExists(sourceSkillDir))) {
            console.log(chalk.yellow(`  âš  Remote skill "${rs.name}" not found on disk, skipping (use "ai-factory skill add" to reinstall)`));
            continue;
          }

          for (const agent of newAgents) {
            try {
              await installRemoteSkill({
                skillDir: sourceSkillDir,
                skillName: rs.name,
                projectDir,
                agentId: agent.id,
              });
              agent.remoteSkills.push({ ...rs });
              const agentDisplay = getAgentConfig(agent.id).displayName;
              console.log(chalk.green(`  âœ“ [${agentDisplay}] Synced remote skill: ${rs.name}`));
            } catch (error) {
              console.log(chalk.yellow(`  âš  Failed to sync "${rs.name}": ${(error as Error).message}`));
            }
          }
        }
        console.log('');
      }
    }

    await saveConfig(projectDir, {
      version: getCurrentVersion(),
      agents: installedAgents,
    });

    console.log(chalk.green('âœ“ Configuration saved to .ai-factory.json'));

    console.log(chalk.bold.green('\nâœ… Setup complete!\n'));

    for (const agent of installedAgents) {
      const agentConfig = getAgentConfig(agent.id);

      console.log(chalk.bold(`${agentConfig.displayName}:`));
      console.log(chalk.dim(`  Skills directory: ${path.join(projectDir, agent.skillsDir)}`));
      console.log(chalk.dim(`  Installed skills: ${agent.installedSkills.length}`));

      const configuredMcp = mcpSummary[agent.id];
      if (configuredMcp && configuredMcp.length > 0) {
        console.log(chalk.green(`  MCP servers configured: ${configuredMcp.join(', ')}`));
        const instructions = getMcpInstructions(configuredMcp);
        for (const instruction of instructions) {
          console.log(chalk.dim(`    ${instruction}`));
        }
      }
      console.log('');
    }

    console.log(chalk.bold('\nNext steps:'));
    const includesCodex = installedAgents.some(agent => agent.id === 'codex');
    const includesQwen = installedAgents.some(agent => agent.id === 'qwen');

    for (const [index, agent] of installedAgents.entries()) {
      const agentConfig = getAgentConfig(agent.id);
      const transformer = getTransformer(agent.id);
      const welcomeMessage = transformer.getWelcomeMessage?.();

      console.log(chalk.dim(`  ${index + 1}. ${agentConfig.displayName}`));
      if (welcomeMessage) {
        for (const line of welcomeMessage) {
          console.log(chalk.dim(`     ${line}`));
        }
      } else {
        console.log(chalk.dim('     Open the agent in this directory'));
        console.log(chalk.dim('     Run /aif to analyze project and generate stack-specific skills'));
      }
    }
    const invocationHints = [
      includesCodex ? 'Codex CLI: $aif-plan, $aif-commit' : null,
      includesQwen ? 'Qwen Code: /skills aif-plan, /skills aif-commit' : null,
    ].filter(Boolean).join('; ');

    console.log(chalk.dim(`  ${installedAgents.length + 1}. Use /aif-plan and /aif-commit for daily workflow${invocationHints ? ` (${invocationHints})` : ''}`));
    console.log('');

  } catch (error) {
    if ((error as Error).message?.includes('User force closed')) {
      console.log(chalk.yellow('\nSetup cancelled.'));
      return;
    }
    throw error;
  }
}

/**
 * Collect unique remote skills across all agents (deduplicated by name).
 */
function collectUniqueRemoteSkills(agents: AgentInstallation[]): RemoteSkill[] {
  const seen = new Map<string, RemoteSkill>();
  for (const agent of agents) {
    for (const rs of agent.remoteSkills) {
      if (!seen.has(rs.name)) {
        seen.set(rs.name, rs);
      }
    }
  }
  return Array.from(seen.values());
}
